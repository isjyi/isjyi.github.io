<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Golang 速查表 | Toradora</title>
<link rel="shortcut icon" href="https://isjyi.github.io/favicon.ico?v=1590385865133">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://isjyi.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Golang 速查表 | Toradora - Atom Feed" href="https://isjyi.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="目录


基础语法


运算符

算术运算符
比较运算符
逻辑运算符
其他



声明


函数

函数作为值和回调使用
可变参数函数



内置类型


类型转换


package


流程控制结构

条件判断（if）
循环（for）
..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://isjyi.github.io">
  <img class="avatar" src="https://isjyi.github.io/images/avatar.png?v=1590385865133" alt="">
  </a>
  <h1 class="site-title">
    Toradora
  </h1>
  <p class="site-description">
    不会飞的猪，只不过是一块猪肉而已。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Golang 速查表
            </h2>
            <div class="post-info">
              <span>
                2020-05-23
              </span>
              <span>
                15 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="目录">目录</h2>
<ol>
<li>
<p>基础语法</p>
</li>
<li>
<p>运算符</p>
<ul>
<li>算术运算符</li>
<li>比较运算符</li>
<li>逻辑运算符</li>
<li>其他</li>
</ul>
</li>
<li>
<p>声明</p>
</li>
<li>
<p>函数</p>
<ul>
<li>函数作为值和回调使用</li>
<li>可变参数函数</li>
</ul>
</li>
<li>
<p>内置类型</p>
</li>
<li>
<p>类型转换</p>
</li>
<li>
<p>package</p>
</li>
<li>
<p>流程控制结构</p>
<ul>
<li>条件判断（if）</li>
<li>循环（for）</li>
<li>多条件分支（switch）</li>
</ul>
</li>
<li>
<p>array, slice, range</p>
<ul>
<li>array</li>
<li>slice</li>
<li>array 和 slice 的操作函数</li>
</ul>
</li>
<li>
<p>map</p>
</li>
<li>
<p>结构体</p>
</li>
<li>
<p>指针</p>
</li>
<li>
<p>接口</p>
</li>
<li>
<p>结构体和接口的组合嵌入</p>
</li>
<li>
<p>Errors</p>
</li>
<li>
<p>并发</p>
<ul>
<li>goroutine</li>
<li>channel</li>
<li>channel 开发原则</li>
</ul>
</li>
<li>
<p>输出</p>
</li>
<li>
<p>代码片段</p>
<ul>
<li>Http-Server</li>
</ul>
</li>
</ol>
<h2 id="前言">前言</h2>
<h3 id="参考">参考</h3>
<p>文中大部分代码都摘抄自 <a href="http://tour.golang.org/">A Tour of Go</a>，对新手来说是很好的参考资料。</p>
<h3 id="go-特性">Go 特性</h3>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B">命令式编程</a></li>
<li>静态类型</li>
<li>类 C 语法（括号使用频率更少 &amp; 无需分号），类 <a href="https://www.inf.ethz.ch/personal/wirth/Oberon/Oberon07.Report.pdf">Oberon-2</a> 的语法结构</li>
<li>代码能编译为本地可执行文件（无需 JVM 类的虚拟机）</li>
<li><code>struct</code> 和 <code>method</code> 取代类的概念</li>
<li>接口</li>
<li><a href="http://golang.org/doc/effective_go.html#embedding">类型组合</a> 取代显式继承</li>
<li>有<a href="https://zh.wikipedia.org/wiki/%E5%A4%B4%E7%AD%89%E5%87%BD%E6%95%B0">头等函数</a></li>
<li>有回调函数</li>
<li>函数可有多个返回值</li>
<li>保留指针，但不能直接参与算术运算</li>
<li>内置并发原语：<code>goroutine</code> 和 <code>channel</code></li>
</ul>
<h2 id="基础语法">基础语法</h2>
<h3 id="hello-world">Hello World</h3>
<p>文件 <code>hello.go</code>：</p>
<pre><code class="language-java">package main

import &quot;fmt&quot;

func main() {
	fmt.Println(&quot;Hello Go&quot;)
}
</code></pre>
<p>运行：<code>$ go run hello.go</code></p>
<h2 id="运算符">运算符</h2>
<h3 id="算术运算符">算术运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>加</td>
</tr>
<tr>
<td>-</td>
<td>减</td>
</tr>
<tr>
<td>*</td>
<td>乘</td>
</tr>
<tr>
<td>/</td>
<td>除</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
</tr>
<tr>
<td>¦</td>
<td>按位或</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
</tr>
<tr>
<td>&amp;^</td>
<td>按位清除（AND NOT）</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>左移</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
</tr>
</tbody>
</table>
<p><code>&amp;^</code> 即是 <code>AND NOT(x, y) = AND(x, NOT(Y))</code>，如：</p>
<h3 id="比较运算符">比较运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>==</td>
<td>相等</td>
</tr>
<tr>
<td>!=</td>
<td>不等</td>
</tr>
<tr>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>&lt;=</td>
<td>小于等于</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于等于</td>
</tr>
</tbody>
</table>
<h3 id="逻辑运算符">逻辑运算符</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;&amp;</td>
<td>逻辑与</td>
</tr>
<tr>
<td>¦¦</td>
<td>逻辑或</td>
</tr>
<tr>
<td>!</td>
<td>取反</td>
</tr>
</tbody>
</table>
<h3 id="其他">其他</h3>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>&amp;</td>
<td>寻址（生成指针）</td>
</tr>
<tr>
<td>*</td>
<td>获取指针指向的数据</td>
</tr>
<tr>
<td>&lt;-</td>
<td>向 channel 中发送 / 接收数据</td>
</tr>
</tbody>
</table>
<h3 id="声明">声明</h3>
<p>与 C 不同，<a href="https://blog.golang.org/declaration-syntax">类型放在标识符后面</a>：</p>
<pre><code class="language-java">var foo int 			// 无初值的声明
var foo int = 42 		// 带初值的声明
var foo, bar int = 42, 1302	// 一次性声明并初始化多个变量
var foo = 42 			// 类型推断，由使用的上下文决定
foo := 42 			// 简短声明，只能用在函数内部
const constant = &quot;This is a constant&quot;
</code></pre>
<h3 id="函数">函数</h3>
<pre><code class="language-java">// 最简单的函数
func functionName() {}

// 带参数的函数(注意类型也是放在标识符之后的)
func functionName(param1 string, param2 int) {}

// 类型相同的多个参数
func functionName(param1, param2 int) {}

// 声明返回值的类型
func functionName() int {
    return 42
}

// 一次返回多个值
func returnMulti() (int, string) {
    return 42, &quot;foobar&quot;
}
var x, str = returnMulti()

// 只使用 return 返回多个命名返回值
func returnMulti2() (n int, s string) {
    n = 42
    s = &quot;foobar&quot;
    // n 和 s 会被返回
    return
}
var x, str = returnMulti2()
</code></pre>
<h3 id="函数作为值和回调使用">函数作为值和回调使用</h3>
<pre><code class="language-java">func main() {
    // 将函数作为值，赋给变量
    add := func(a, b int) int {
        return a + b
    }
    // 使用变量直接调用函数
    fmt.Println(add(3, 4))
}

// 回调函数作用域：在定义回调函数时能访问外部函数的值
func scope() func() int{
    outer_var := 2
    foo := func() int { return outer_var}
    return foo
}

func another_scope() func() int{
    // 编译错误，两个变量不在此函数作用域内
    // undefined: outer_var
    outer_var = 444
    return foo
}

// 回调函数不会修改外部作用域的数据
func outer() (func() int, int) {
    outer_var := 2
    inner := func() int {
        outer_var += 99 	// 试着使用外部作用域的 outer_var 变量
        return outer_var 	// 返回值是 101，但只在 inner() 内部有效
    }
    return inner, outer_var	// 返回值是 inner, 2 (outer_var 仍是 2）
}

inner, outer_var := outer();	// inner, 2
inner();	// 返回 101
inner();	// 返回 200	// 回调函数的特性
</code></pre>
<h3 id="可变参数函数">可变参数函数</h3>
<pre><code class="language-java">func main() {
	fmt.Println(adder(1, 2, 3)) 	// 6
	fmt.Println(adder(9, 9))	// 18
	
	nums := []int{10, 20, 30}
	fmt.Println(adder(nums...))	// 60
}

// 在函数的最后一个参数类型前，使用 ... 可表明函数还能接收 0 到多个此种类型的参数
// 下边的函数在调用时传多少个参数都可以
func adder(args ...int) int {
	total := 0
	for _, v := range args {	// 使用迭代器逐个访问参数
		total += v
	}
	return total
}
</code></pre>
<h3 id="内置类型">内置类型</h3>
<pre><code class="language-java">bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 类型的别名	// 存储 raw data

rune // int32 类型的别名	// 一个 Unicode code point 字符

float32 float64

complex64 complex128
</code></pre>
<h3 id="类型转换">类型转换</h3>
<pre><code class="language-java">var i int = 42
var f float64 = float64(i)
var u uint = uint(f)

// 简化语法
i := 42
f := float64(i)
u := uint(f)
</code></pre>
<h3 id="package">package</h3>
<ol>
<li>package 在源文件开头声明</li>
<li>main package 才是可执行文件</li>
<li>约定：package 名字与 import 路径的最后一个单词一致（如导入 math/rand 则 package 叫 rand）</li>
<li>大写开头的标识符（变量名、函数名…）：对其他 package 是可访问的</li>
<li>小写开头的标识符：对其他 package 是不可见的</li>
</ol>
<h2 id="流程控制结构">流程控制结构</h2>
<h3 id="if">if</h3>
<pre><code class="language-java">func main() {
	// 一般的条件判断
	if x &gt; 0 {
		return x
	} else {
		return -x
	}
    	
	// 在条件判断语句前可塞一条语句，使代码更简洁
	if a := b + c; a &lt; 42 {
		return a
	} else {
		return a - 42
	}
    
	// 使用 if 做类型断言
	var val interface{}
	val = &quot;foo&quot;
	if str, ok := val.(string); ok {
		fmt.Println(str)
	}
}
</code></pre>
<h3 id="loops">Loops</h3>
<pre><code class="language-java">// Go 语言中循环结构只有 for，没有 do、while、until、foreach 等等
for i := 1; i &lt; 10; i++ {
}
for ; i &lt; 10;  { 	// 等效于 while 循环
}
for i &lt; 10  { 		// 只有一个判断条件时可省去分号
}
for { 			// 无条件循环时，等效于 while(true)
}
</code></pre>
<h3 id="switch">switch</h3>
<pre><code class="language-java">// switch 分支语句
switch operatingSystem {
    case &quot;darwin&quot;:
        fmt.Println(&quot;Mac OS Hipster&quot;)
        // case 语句自带 break，想执行所有 case 需要手动 fallthrough
    case &quot;linux&quot;:
        fmt.Println(&quot;Linux Geek&quot;)
    default:
        // Windows, BSD, ...
        fmt.Println(&quot;Other&quot;)
}

// 和 if、for 语句一样，可在判断变量之前加入一条赋值语句
switch os := runtime.GOOS; os {
    case &quot;darwin&quot;: ...
}

// 在 switch 中还能做比较，相当于 switch (true) {...}
number := 42
switch {
    case number &lt; 42:
        fmt.Println(&quot;Smaller&quot;)
    case number == 42:
        fmt.Println(&quot;Equal&quot;)
    case number &gt; 42:
        fmt.Println(&quot;Greater&quot;)
}

// 多个 case 可使用逗号分隔统一处理
var char byte = '?'
switch char {
    case ' ', '?', '&amp;', '=', '#', '+', '%':
    fmt.Println(&quot;Should escape&quot;)
}
</code></pre>
<h2 id="arrays-slices-ranges">Arrays, Slices, Ranges</h2>
<h3 id="arrays">Arrays</h3>
<pre><code class="language-java">var a [10]int // 声明长度为 10 的 int 型数组，注意数组类型 = （元素类型 int，元素个数 10）
a[3] = 42     // 设置元素值
i := a[3]     // 读取元素值

// 声明并初始化数组
var a = [2]int{1, 2}
a := [2]int{1, 2} 	// 简短声明
a := [...]int{1, 2}	// 数组长度使用 ... 代替，编译器会自动计算元素个数
</code></pre>
<h3 id="slices">slices</h3>
<pre><code class="language-java">var a []int           		// 声明 slice，相当于声明未指定长度的数组
var a = []int {1, 2, 3, 4}	// 声明并初始化 slice (基于 {} 中给出的底层数组)
a := []int{1, 2, 3, 4}		// 简短声明
chars := []string{0:&quot;a&quot;, 2:&quot;c&quot;, 1: &quot;b&quot;}  // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]

var b = a[lo:hi]	// 创建从 lo 到 hi-1 的 slice 
var b = a[1:4]		// 创建从 1  到 3    的 slice
var b = a[:3]		// 缺省 start index 则默认为 0 
var b = a[3:]		// 缺省 end   index 则默认为 len(a)
a =  append(a,17,3)	// 向 slice a 中追加 17 和 3
c := append(a,b...)	// 合并两个 slice

// 使用 make 创建 slice
a = make([]byte, 5, 5)	// 第一个参数是长度，第二个参数是容量
a = make([]byte, 5)	// 容量参数是可选的

// 从数组创建 slice
x := [3]string{&quot;Лайка&quot;, &quot;Белка&quot;, &quot;Стрелка&quot;}
s := x[:] 		// slice s 指向底层数组 x
</code></pre>
<h3 id="数组和-slice-的操作函数">数组和 slice 的操作函数</h3>
<pre><code class="language-java">// 迭代数组或 slice
for i, e := range a {
    // i 是索引
    // e 是元素值
}

// 如果你只要值，可用 _ 来丢弃返回的索引
for _, e := range a {
}

// 如果你只要索引
for i := range a {
}

// 在 Go 1.4 以前的版本，如果 i 和 e 你都不用，直接 range 编译器会报错
for range time.Tick(time.Second) {
    // 每隔 1s 执行一次
}
</code></pre>
<h3 id="map">map</h3>
<pre><code class="language-java">var m map[string]int
m = make(map[string]int)
m[&quot;key&quot;] = 42
fmt.Println(m[&quot;key&quot;])

delete(m, &quot;key&quot;)

elem, ok := m[&quot;key&quot;] // 检查 m 中是否键为 key 的元素，如果有 ok 才为 true

// 使用键值对的形式来初始化 map
var m = map[string]Vertex{
    &quot;Bell Labs&quot;: {40.68433, -74.39967},
    &quot;Google&quot;:    {37.42202, -122.08408},
}
</code></pre>
<h3 id="结构体">结构体</h3>
<p>Go 语言中没有 class 类的概念，取而代之的是 struct，struct 的方法对应到类的成员函数。</p>
<pre><code class="language-java">// struct 是一种类型，也是字段成员的集合体

// 声明 struct
type Vertex struct {
    X, Y int
}

// 初始化 struct
var v = Vertex{1, 2}			// 字段名有序对应值
var v = Vertex{X: 1, Y: 2} 		// 字段名对应值
var v = []Vertex{{1,2},{5,2},{5,5}}	// 初始化多个 struct 组成的 slice

// 访问成员
v.X = 4

// 在 func 关键字和函数名之间，声明接收者是 struct
// 在方法内部，struct 实例被复制，传值引用
func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

// 调用方法(有接收者的函数)
v.Abs()

// 有的方法接收者是指向 struct 的指针
// 此时在方法内调用实例，将是传址引用
func (v *Vertex) add(n float64) {
    v.X += n
    v.Y += n
}
</code></pre>
<h3 id="匿名结构体">匿名结构体</h3>
<p>使用 <code>map[string]interface{}</code> 开销更小且更为安全。</p>
<pre><code class="language-java">point := struct {
	X, Y int
}{1, 2}
</code></pre>
<h3 id="指针">指针</h3>
<pre><code class="language-java">p := Vertex{1, 2}  // p 是一个 Vertex
q := &amp;p            // q 是指向 Vertex 的指针
r := &amp;Vertex{1, 2} // r 也是指向 Vertex 的指针

var s *Vertex = new(Vertex) // new 返回的指向该实例指针
</code></pre>
<h3 id="接口">接口</h3>
<pre><code class="language-java">// 声明接口
type Awesomizer interface {
    Awesomize() string
}

// 无需手动声明 implement 接口
type Foo struct {}

// 自定义类型如果实现了接口的所有方法，那它就自动实现了该接口
func (foo Foo) Awesomize() string {
    return &quot;Awesome!&quot;
}
</code></pre>
<h3 id="结构体和接口的组合嵌入">结构体和接口的组合嵌入</h3>
<pre><code class="language-java">// 实现 ReadWriter 的类型要同时实现了 Reader 和 Writer 两个接口
type ReadWriter interface {
    Reader
    Writer
}

// Server 暴露出 Logger 所有开放的方法
type Server struct {
    Host string
    Port int
    *log.Logger
}

// 初始化自定义的组合类型
server := &amp;Server{&quot;localhost&quot;, 80, log.New(...)}

// 组合的结构体能直接跨节点调用方法
server.Log(...) // 等同于调用 server.Logger.Log(...)

// 字段同理
var logger *log.Logger = server.Logger
</code></pre>
<h3 id="errors">Errors</h3>
<p>Go 中没有异常处理机制，函数在调用时在有可能会产生错误，可返回一个 <code>Error</code> 类型的值，<code>Error</code> 接口：</p>
<pre><code class="language-java">type error interface {
    Error() string
}
</code></pre>
<p>一个可能产生错误的函数：</p>
<pre><code class="language-java">func doStuff() (int, error) {
}

func main() {
    result, err := doStuff()
    if err != nil {
        // 错误处理
    }
    // 使用 result 处理正常逻辑
}
</code></pre>
<h2 id="并发">并发</h2>
<h3 id="goroutine">goroutine</h3>
<p>goroutine（协程）是轻量级的线程（Go runtime 自行管理，而不是操作系统），代码 <code>go f(a, b)</code> 就开了一个运行 f 函数的协程。</p>
<pre><code class="language-java">func doStuff(s string) {
}

func main() {
    // 在协程中执行函数
    go doStuff(&quot;foobar&quot;)

    // 在协程中执行匿名函数
    go func (x int) {
        // 函数实现
    }(42)
}
</code></pre>
<h3 id="channels">Channels</h3>
<pre><code class="language-java">ch := make(chan int) 	// 创建类型为 int 的 channel
ch &lt;- 42             	// 向 channel ch 写数据 42
v := &lt;-ch            	// 从 channel ch 读数据，此时 v 的值为 42
			// 无缓冲的 channel 此时会阻塞
			// 如果 channel 中无数据，则读操作会被阻塞，直到有数据可读

// 创建带缓冲的 channel
// 向带缓冲的 channel 写数据不会被阻塞，除非该缓冲区已满
ch := make(chan int, 100)

close(ch) // 发送者主动关闭 channel

// 在从 channel 读数据的同时检测其是否已关闭
// 如果 ok 为 false，则 ch 已被关闭
v, ok := &lt;-ch	

// 从 channel 中读数据直到它被关闭
for i := range ch {
    fmt.Println(i)
}

// select 语句中 任一 channel 不阻塞则自动执行对应的 case
func doStuff(channelOut, channelIn chan int) {
    select {
        case channelOut &lt;- 42:
            fmt.Println(&quot;We could write to channelOut!&quot;)
        case x := &lt;- channelIn:
            fmt.Println(&quot;We could read from channelIn&quot;)
        case &lt;-time.After(time.Second * 1):
            fmt.Println(&quot;timeout&quot;)
    }
}
</code></pre>
<h3 id="channel-开发原则">channel 开发原则</h3>
<ol>
<li>向 nil channel 写数据将卡死，一直阻塞<br>
<img src="https://isjyi.github.io/post-images/1590195763082.png" alt="" loading="lazy"></li>
<li>从 nil channel 读数据将卡死，一直阻塞<br>
<img src="https://isjyi.github.io/post-images/1590195782100.png" alt="" loading="lazy"></li>
<li>向已关闭的 channel 写数据将造成 panic</li>
</ol>
<pre><code class="language-java">package main

func main() {
	var c = make(chan string, 1)
	c &lt;- &quot;Hello, World!&quot;
	close(c)
	c &lt;- &quot;Hello, Panic!&quot;
}
</code></pre>
<p>运行：<br>
<img src="https://isjyi.github.io/post-images/1590195807064.png" alt="" loading="lazy"><br>
4. 从已关闭的 channel 读数据将返回零值</p>
<pre><code class="language-java">package main

func main() {
	var c = make(chan int, 2)
	c &lt;- 1
	c &lt;- 2
	close(c)
	for i := 0; i &lt; 3; i++ {
		println(&lt;-c)
	}
}
</code></pre>
<p>运行：<br>
<img src="https://isjyi.github.io/post-images/1590195833694.png" alt="" loading="lazy"></p>
<h3 id="输出">输出</h3>
<pre><code class="language-java">fmt.Println(&quot;Hello, 你好, नमस्ते, Привет, ᎣᏏᏲ&quot;) 		// 最基本的输出，会自动加一个换行
p := struct { X, Y int }{ 17, 2 }
fmt.Println( &quot;My point:&quot;, p, &quot;x coord=&quot;, p.X ) 		// 输出结构体字段等
s := fmt.Sprintln( &quot;My point:&quot;, p, &quot;x coord=&quot;, p.X )	// 组合字符串并返回

fmt.Printf(&quot;%d hex:%x bin:%b fp:%f sci:%e&quot;,17,17,17,17.0,17.0) // 类 C 的格式化输出
s2 := fmt.Sprintf( &quot;%d %f&quot;, 17, 17.0 )			// 格式化字符串并返回

hellomsg := `
 &quot;Hello&quot; in Chinese is 你好 ('Ni Hao')
 &quot;Hello&quot; in Hindi is नमस्ते ('Namaste')
` 
// 声明多行字符串，在前后均使用反引号 `
</code></pre>
<h2 id="代码片段">代码片段</h2>
<h3 id="http-server">HTTP Server</h3>
<pre><code class="language-java">package main

import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

// 定义响应的数据结构
type Hello struct{}

// Hello 实现 http.Handler 中定义的 ServeHTTP 方法
func (h Hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, &quot;Hello!&quot;)
}

func main() {
    var h Hello
    http.ListenAndServe(&quot;localhost:4000&quot;, h)
}

// http.ServeHTTP 在接口内的定义如下：
// type Handler interface {
//     ServeHTTP(w http.ResponseWriter, r *http.Request)
// }
</code></pre>
<p>运行：<br>
<img src="https://isjyi.github.io/post-images/1590195724049.png" alt="" loading="lazy"></p>
<h3 id="总结">总结</h3>
<p>上边十七个知识点简要概括了常见语法，可复习使用，但涉及到的细节不多，细读《Go 程序设计语言》 才是。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a>
<ul>
<li><a href="#%E5%8F%82%E8%80%83">参考</a></li>
<li><a href="#go-%E7%89%B9%E6%80%A7">Go 特性</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95">基础语法</a>
<ul>
<li><a href="#hello-world">Hello World</a></li>
</ul>
</li>
<li><a href="#%E8%BF%90%E7%AE%97%E7%AC%A6">运算符</a>
<ul>
<li><a href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6">算术运算符</a></li>
<li><a href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6">比较运算符</a></li>
<li><a href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></li>
<li><a href="#%E5%85%B6%E4%BB%96">其他</a></li>
<li><a href="#%E5%A3%B0%E6%98%8E">声明</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%80%BC%E5%92%8C%E5%9B%9E%E8%B0%83%E4%BD%BF%E7%94%A8">函数作为值和回调使用</a></li>
<li><a href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0">可变参数函数</a></li>
<li><a href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B">内置类型</a></li>
<li><a href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">类型转换</a></li>
<li><a href="#package">package</a></li>
</ul>
</li>
<li><a href="#%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84">流程控制结构</a>
<ul>
<li><a href="#if">if</a></li>
<li><a href="#loops">Loops</a></li>
<li><a href="#switch">switch</a></li>
</ul>
</li>
<li><a href="#arrays-slices-ranges">Arrays, Slices, Ranges</a>
<ul>
<li><a href="#arrays">Arrays</a></li>
<li><a href="#slices">slices</a></li>
<li><a href="#%E6%95%B0%E7%BB%84%E5%92%8C-slice-%E7%9A%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">数组和 slice 的操作函数</a></li>
<li><a href="#map">map</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93">结构体</a></li>
<li><a href="#%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93">匿名结构体</a></li>
<li><a href="#%E6%8C%87%E9%92%88">指针</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3">接口</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BB%84%E5%90%88%E5%B5%8C%E5%85%A5">结构体和接口的组合嵌入</a></li>
<li><a href="#errors">Errors</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6%E5%8F%91">并发</a>
<ul>
<li><a href="#goroutine">goroutine</a></li>
<li><a href="#channels">Channels</a></li>
<li><a href="#channel-%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99">channel 开发原则</a></li>
<li><a href="#%E8%BE%93%E5%87%BA">输出</a></li>
</ul>
</li>
<li><a href="#%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5">代码片段</a>
<ul>
<li><a href="#http-server">HTTP Server</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://isjyi.github.io/post/etcd-ji-ben-shi-yong/">
              <h3 class="post-title">
                ETCD 基本使用
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://isjyi.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
