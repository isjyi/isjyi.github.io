<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>IP | Toradora</title>
<link rel="shortcut icon" href="https://isjyi.github.io/favicon.ico?v=1590385865133">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://isjyi.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="IP | Toradora - Atom Feed" href="https://isjyi.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="IP 协议简介
IP 协议位于 TCP/IP 协议的第三层——网络层。与传输层协议相比，网络层的责任是提供点到点(hop by hop)的服务，而传输层（TCP/UDP）则提供端到端(end to end)的服务。
IP 地址的分类
A类地..." />
    <meta name="keywords" content="Network" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://isjyi.github.io">
  <img class="avatar" src="https://isjyi.github.io/images/avatar.png?v=1590385865133" alt="">
  </a>
  <h1 class="site-title">
    Toradora
  </h1>
  <p class="site-description">
    不会飞的猪，只不过是一块猪肉而已。
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              IP
            </h2>
            <div class="post-info">
              <span>
                2019-01-12
              </span>
              <span>
                6 min read
              </span>
              
                <a href="https://isjyi.github.io/tag/4681DluM2/" class="post-tag">
                  # Network
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="ip-协议简介">IP 协议简介</h2>
<p>IP 协议位于 TCP/IP 协议的第三层——网络层。与传输层协议相比，网络层的责任是提供点到点(hop by hop)的服务，而传输层（TCP/UDP）则提供端到端(end to end)的服务。</p>
<h2 id="ip-地址的分类">IP 地址的分类</h2>
<h3 id="a类地址">A类地址</h3>
<h3 id="b类地址">B类地址</h3>
<h3 id="c类地址">C类地址</h3>
<h3 id="d类地址">D类地址</h3>
<h2 id="广播与多播">广播与多播</h2>
<p>广播和多播仅用于UDP（TCP是面向连接的）。</p>
<ul>
<li>
<p>广播</p>
<p>一共有四种广播地址：</p>
<ol>
<li>
<p>受限的广播</p>
<p>受限的广播地址为255.255.255.255。该地址用于主机配置过程中IP数据报的目的地址，在任何情况下，router不转发目的地址为255.255.255.255的数据报，这样的数据报仅出现在本地网络中。</p>
</li>
<li>
<p>指向网络的广播</p>
<p>指向网络的广播地址是主机号为全1的地址。A类网络广播地址为netid.255.255.255，其中netid为A类网络的网络号。</p>
<p>一个router必须转发指向网络的广播，但它也必须有一个不进行转发的选择。</p>
</li>
<li>
<p>指向子网的广播</p>
<p>指向子网的广播地址为主机号为全1且有特定子网号的地址。作为子网直接广播地址的IP地址需要了解子网的掩码。例如，router收到128.1.2.255的数据报，当B类网路128.1的子网掩码为255.255.255.0时，该地址就是指向子网的广播地址；但是如果子网掩码为255.255.254.0，该地址就不是指向子网的广播地址。</p>
</li>
<li>
<p>指向所有子网的广播</p>
<p>指向所有子网的广播也需要了解目的网络的子网掩码，以便与指向网络的广播地址区分开来。指向所有子网的广播地址的子网号和主机号为全1.例如，如果子网掩码为255.255.255.0，那么128.1.255.255就是一个指向所有子网的广播地址。</p>
<p>当前的看法是这种广播是陈旧过时的，更好的方式是使用多播而不是对所有子网的广播。</p>
<p>广播示例:</p>
<pre><code>PING 192.168.0.255 (192.168.0.255): 56 data bytes
64 bytes from 192.168.0.107: icmp_seq=0 ttl=64 time=0.199 ms
64 bytes from 192.168.0.106: icmp_seq=0 ttl=64 time=45.357 ms
64 bytes from 192.168.0.107: icmp_seq=1 ttl=64 time=0.203 ms
64 bytes from 192.168.0.106: icmp_seq=1 ttl=64 time=269.475 ms
64 bytes from 192.168.0.107: icmp_seq=2 ttl=64 time=0.102 ms
64 bytes from 192.168.0.106: icmp_seq=2 ttl=64 time=189.881 ms
</code></pre>
<p>可以看到的确收到了来自两个主机的答复，其中 192.168.0.107 是本机地址。</p>
</li>
</ol>
</li>
<li>
<p>多播</p>
<p>多播又叫组播，使用D类地址，D类地址分配的28bit均用作多播组号而不再表示其他。</p>
<p>多播组地址包括1110的最高4bit和多播组号。它们通常可以表示为点分十进制数，范围从224.0.0.0到239.255.255.255。</p>
<p>多播的出现减少了对应用不感兴趣主机的处理负荷。</p>
<p>多播的特点：</p>
<ul>
<li>
<p>允许一个或多个发送者（组播源）发送单一的数据包到多个接收者（一次的，同时的）的网络技术</p>
</li>
<li>
<p>可以大大的节省网络带宽，因为无论有多少个目标地址，在整个网络的任何一条链路上只传送单一的数据包</p>
</li>
<li>
<p>多播技术的核心就是针对如何节约网络资源的前提下保证服务质量。</p>
<p>多播示例：</p>
<pre><code>PING 224.0.0.1 (224.0.0.1): 56 data bytes
64 bytes from 192.168.0.107: icmp_seq=0 ttl=64 time=0.081 ms
64 bytes from 192.168.0.106: icmp_seq=0 ttl=64 time=123.081 ms
64 bytes from 192.168.0.107: icmp_seq=1 ttl=64 time=0.122 ms
64 bytes from 192.168.0.106: icmp_seq=1 ttl=64 time=67.312 ms
64 bytes from 192.168.0.107: icmp_seq=2 ttl=64 time=0.132 ms
64 bytes from 192.168.0.106: icmp_seq=2 ttl=64 time=447.073 ms
64 bytes from 192.168.0.107: icmp_seq=3 ttl=64 time=0.132 ms
64 bytes from 192.168.0.106: icmp_seq=3 ttl=64 time=188.800 ms  
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="bgp">BGP</h2>
<ul>
<li>边界网关协议（BGP）是运行于 TCP 上的一种自治系统的路由协议</li>
<li>BGP 是唯一一个用来处理像因特网大小的网络的协议，也是唯一能够妥善处理好不相关路由域间的多路连接的协议</li>
<li>BGP是一种外部网关协议（Exterior Gateway Protocol，EGP），与OSPF、RIP等内部网关协议（Interior Gateway Protocol，IGP）不同，BGP不在于发现和计算路由，而在于控制路由的传播和选择最佳路由</li>
<li>BGP使用TCP作为其传输层协议（端口号179），提高了协议的可靠性</li>
<li>BGP既不是纯粹的矢量距离协议，也不是纯粹的链路状态协议</li>
<li>BGP支持CIDR（Classless Inter-Domain Routing，无类别域间路由）</li>
<li>路由更新时，BGP只发送更新的路由，大大减少了BGP传播路由所占用的带宽，适用于在Internet上传播大量的路由信息</li>
<li>BGP路由通过携带AS路径信息彻底解决路由环路问题</li>
<li>BGP提供了丰富的路由策略，能够对路由实现灵活的过滤和选择</li>
<li>BGP易于扩展，能够适应网络新的发展</li>
</ul>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/Torres_fans/archive/2011/03/21/1990377.html">多播与广播</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_ac9fdc0b0101pw7w.html">TCP_IP：广播和多播</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E8%BE%B9%E7%95%8C%E7%BD%91%E5%85%B3%E5%8D%8F%E8%AE%AE">维基百科：BGP</a></li>
</ul>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#ip-%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B">IP 协议简介</a></li>
<li><a href="#ip-%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB">IP 地址的分类</a>
<ul>
<li><a href="#a%E7%B1%BB%E5%9C%B0%E5%9D%80">A类地址</a></li>
<li><a href="#b%E7%B1%BB%E5%9C%B0%E5%9D%80">B类地址</a></li>
<li><a href="#c%E7%B1%BB%E5%9C%B0%E5%9D%80">C类地址</a></li>
<li><a href="#d%E7%B1%BB%E5%9C%B0%E5%9D%80">D类地址</a></li>
</ul>
</li>
<li><a href="#%E5%B9%BF%E6%92%AD%E4%B8%8E%E5%A4%9A%E6%92%AD">广播与多播</a></li>
<li><a href="#bgp">BGP</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://isjyi.github.io/post/udp/">
              <h3 class="post-title">
                UDP
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  
  <a class="rss" href="https://isjyi.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
